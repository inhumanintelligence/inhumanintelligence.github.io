<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Kay</title>
<link href="https://fonts.googleapis.com/css2?family=Nunito:wght@400;600;700;800;900&family=Fredoka+One&display=swap" rel="stylesheet">
<style>
  *, *::before, *::after { margin: 0; padding: 0; box-sizing: border-box; }

  body {
    min-height: 100vh;
    font-family: 'Nunito', sans-serif;
    display: flex; flex-direction: column;
    align-items: center; justify-content: center;
    overflow-x: hidden; padding: 48px 24px;
    background: #0a0a0a;
  }

  .bg {
    position: fixed; inset: 0;
    background: url('438ff2ad92e75220bba802cc4e824def.jpg') center center / cover no-repeat;
    filter: blur(22px) brightness(0.5) grayscale(0.5) contrast(1.05);
    transform: scale(1.1); z-index: 0;
  }

  .vignette {
    position: fixed; inset: 0;
    background: radial-gradient(ellipse at center,
      rgba(0,0,0,0.05) 0%, rgba(0,0,0,0.3) 55%, rgba(0,0,0,0.7) 100%);
    z-index: 1;
  }

  .scanlines {
    position: fixed; inset: 0;
    background: repeating-linear-gradient(to bottom,
      transparent 0px, transparent 3px,
      rgba(0,0,0,0.06) 3px, rgba(0,0,0,0.06) 4px);
    z-index: 2; pointer-events: none;
  }

  /* ── ENTER SCREEN ── */
  #enter-screen {
    position: fixed; inset: 0; z-index: 1000;
    display: flex; flex-direction: column;
    align-items: center; justify-content: center; gap: 20px;
    cursor: pointer;
    transition: opacity 0.9s ease;
  }

  #enter-screen.hiding {
    opacity: 0;
    pointer-events: none;
  }



  .enter-label {
    font-family: 'Fredoka One', cursive;
    font-size: 22px;
    font-weight: 400;
    letter-spacing: 2px;
    color: rgba(255,255,255,0.75);
    text-transform: lowercase;
    animation: labelBreath 2.4s ease-in-out infinite;
  }

  @keyframes labelBreath {
    0%,100% { opacity: 0.3; }
    50%      { opacity: 0.8; }
  }

  /* ── MAIN WRAP (blurs in) ── */
  #main-wrap {
    position: relative; z-index: 10;
    display: flex; flex-direction: column;
    align-items: center; gap: 16px;
    width: 100%; max-width: 400px;
    filter: blur(18px) brightness(0.3);
    opacity: 0;
    pointer-events: none;
    transition: filter 1.3s cubic-bezier(0.23,1,0.32,1),
                opacity 0.9s ease;
  }

  #main-wrap.revealed {
    filter: blur(0px) brightness(1);
    opacity: 1;
    pointer-events: all;
  }

  /* ── CARD ── */
  @property --angle {
    syntax: '<angle>';
    initial-value: 0deg;
    inherits: false;
  }

  .card-wrap {
    position: relative; width: 100%;
    border-radius: 34px; padding: 2px;
    animation: popIn 0.7s cubic-bezier(0.34,1.56,0.64,1) both;
  }

  .card-wrap::before {
    content: '';
    position: absolute; inset: 0; border-radius: 34px;
    background: conic-gradient(
      from var(--angle),
      #000 0%, #111 10%, #2a2a2a 18%,
      #555 25%, #909090 32%, #d0d0d0 38%,
      #fff 43%, #d0d0d0 48%, #909090 55%,
      #555 62%, #2a2a2a 70%, #111 78%,
      #000 85%, #000 100%
    );
    animation: borderSpin 2.8s linear infinite;
    z-index: 0;
  }

  @keyframes borderSpin { to { --angle: 360deg; } }

  .card {
    position: relative; z-index: 1; width: 100%;
    background: rgba(14,14,14,0.95);
    backdrop-filter: blur(32px); -webkit-backdrop-filter: blur(32px);
    border-radius: 32px; padding: 40px 36px 36px;
    display: flex; flex-direction: column;
    align-items: center; gap: 24px;
    box-shadow: 0 1px 0 rgba(255,255,255,0.07) inset, 0 24px 64px rgba(0,0,0,0.8);
    transition: none;
    will-change: transform;
  }

  @keyframes popIn {
    from { opacity: 0; transform: scale(0.92) translateY(20px); }
    to   { opacity: 1; transform: scale(1) translateY(0); }
  }

  /* ── AVATAR ── */
  .avatar-wrap {
    position: relative; width: 90px; height: 90px;
    display: flex; align-items: center; justify-content: center;
  }

  .avatar-ring {
    position: absolute; inset: -1px; border-radius: 50%;
    background: conic-gradient(
      #444 0deg, #1a1a1a 60deg, #000 120deg,
      #1a1a1a 180deg, #555 240deg, #1a1a1a 300deg, #444 360deg
    );
    -webkit-mask: radial-gradient(circle, transparent 41.5px, black 42.5px);
    mask: radial-gradient(circle, transparent 41.5px, black 42.5px);
    animation: spin 2.5s linear infinite;
  }

  @keyframes spin { to { transform: rotate(360deg); } }

  .avatar {
    width: 82px; height: 82px; border-radius: 50%;
    overflow: hidden; background: #111; border: 1px solid #1a1a1a;
  }

  .avatar img {
    width: 100%; height: 100%; object-fit: cover;
    object-position: 72% 78%; display: block;
    filter: grayscale(30%) brightness(0.85) contrast(1.1);
  }

  /* Avatar status badge */
  .avatar-badge {
    position: absolute; bottom: 2px; right: 2px;
    width: 18px; height: 18px;
    border: 3px solid #0e0e0e;
    border-radius: 50%;
    background: #747f8d;
    transition: background 0.4s, box-shadow 0.4s;
  }

  /* Online */
  .avatar-badge.online { background: #23a55a; box-shadow: 0 0 8px rgba(35,165,90,0.6); }

  /* Idle — crescent moon shape */
  .avatar-badge.idle {
    background: #f0b232;
    box-shadow: 0 0 8px rgba(240,178,50,0.5);
    -webkit-mask:
      radial-gradient(circle at 100% 0%, transparent 55%, black 56%);
    mask:
      radial-gradient(circle at 100% 0%, transparent 55%, black 56%);
  }

  /* DND — red circle with white bar */
  .avatar-badge.dnd {
    background: #f23f43;
    box-shadow: 0 0 8px rgba(242,63,67,0.5);
  }
  .avatar-badge.dnd::after {
    content: '';
    position: absolute; left: 50%; top: 50%;
    transform: translate(-50%, -50%);
    width: 58%; height: 2.5px;
    background: #0e0e0e;
    border-radius: 2px;
  }

  /* Offline */
  .avatar-badge.offline { background: #747f8d; box-shadow: none; }

  /* ── NAME ── */
  .name-section {
    display: flex; flex-direction: column; align-items: center; gap: 6px;
  }

  h1 {
    font-size: 32px; font-weight: 900;
    letter-spacing: -0.8px; color: #f0f0f0;
    text-shadow: 0 2px 20px rgba(0,0,0,0.8);
  }

  .handle {
    font-size: 12px; font-weight: 700;
    color: #666; letter-spacing: 1.5px; text-transform: uppercase;
  }

  /* ── STATUS PILL ── */
  .discord-status {
    display: flex; align-items: center; gap: 8px;
    background: #0d0d0d; border: 1px solid #1f1f1f;
    border-radius: 100px; padding: 6px 16px;
  }

  .status-indicator {
    width: 10px; height: 10px;
    flex-shrink: 0; position: relative;
  }

  /* Online dot */
  .status-indicator.online {
    border-radius: 50%;
    background: #23a55a;
    box-shadow: 0 0 6px rgba(35,165,90,0.6);
  }

  /* Idle crescent */
  .status-indicator.idle {
    border-radius: 50%;
    background: #f0b232;
    box-shadow: 0 0 6px rgba(240,178,50,0.5);
    -webkit-mask: radial-gradient(circle at 100% 0%, transparent 50%, black 51%);
    mask: radial-gradient(circle at 100% 0%, transparent 50%, black 51%);
  }

  /* DND circle + bar */
  .status-indicator.dnd {
    border-radius: 50%;
    background: #f23f43;
    box-shadow: 0 0 6px rgba(242,63,67,0.5);
  }
  .status-indicator.dnd::after {
    content: '';
    position: absolute; left: 50%; top: 50%;
    transform: translate(-50%, -50%);
    width: 60%; height: 2px;
    background: #0d0d0d;
    border-radius: 1px;
  }

  /* Offline hollow circle */
  .status-indicator.offline {
    border-radius: 50%;
    background: transparent;
    border: 2px solid #747f8d;
    width: 10px; height: 10px;
  }

  .status-label {
    font-size: 11px; font-weight: 700; color: #555; letter-spacing: 0.5px;
  }

  /* ── CUSTOM STATUS ── */
  .custom-status {
    font-size: 11px; font-weight: 700; color: #444;
    letter-spacing: 0.3px; max-width: 260px;
    text-align: center;
    white-space: nowrap; overflow: hidden; text-overflow: ellipsis;
    display: none;
  }

  /* ── NOW PLAYING ── */
  .now-playing {
    width: 100%; background: #0d0d0d;
    border: 1px solid #1f1f1f; border-radius: 18px;
    padding: 14px 18px;
    display: none; align-items: center; gap: 12px;
    cursor: default;
  }
  .now-playing.visible { display: flex; }

  .spotify-art {
    width: 38px; height: 38px; border-radius: 8px;
    object-fit: cover; flex-shrink: 0;
    display: none; background: #1a1a1a;
  }
  .spotify-art.loaded { display: block; }

  .bars {
    display: flex; align-items: flex-end;
    gap: 2px; height: 16px; flex-shrink: 0;
  }
  .bar {
    width: 3px; border-radius: 2px; background: #1DB954;
    animation: bounce var(--d) ease-in-out infinite alternate;
  }
  .bar:nth-child(1) { --d:.6s; height:6px; }
  .bar:nth-child(2) { --d:.4s; height:14px; }
  .bar:nth-child(3) { --d:.7s; height:10px; }
  .bar:nth-child(4) { --d:.5s; height:16px; }

  @keyframes bounce {
    from { transform: scaleY(0.3); }
    to   { transform: scaleY(1); }
  }

  .track-info {
    display: flex; flex-direction: column; gap: 2px; overflow: hidden; flex: 1;
  }
  .track-label {
    font-size: 9px; font-weight: 800; color: #1DB954;
    letter-spacing: 1.2px; text-transform: uppercase; margin-bottom: 2px;
  }
  .track-name {
    font-size: 12px; font-weight: 800; color: #ccc;
    white-space: nowrap; overflow: hidden; text-overflow: ellipsis;
  }
  .track-artist { font-size: 11px; font-weight: 600; color: #444; }
</style>
</head>
<body>

<div class="bg"></div>
<div class="vignette"></div>
<div class="scanlines"></div>

<!-- ENTER SCREEN -->
<div id="enter-screen">
  <span class="enter-label">click to enter</span>
</div>

<!-- MAIN (blurred until click) -->
<div id="main-wrap">
  <audio id="preview-audio" loop preload="none"></audio>

  <div class="card-wrap">
    <div class="card" id="card">

      <div class="avatar-wrap">
        <div class="avatar-ring"></div>
        <div class="avatar">
          <img src="438ff2ad92e75220bba802cc4e824def.jpg" alt="Kay">
        </div>
        <div class="avatar-badge" id="avatarBadge"></div>
      </div>

      <div class="name-section">
        <h1>Kay</h1>
        <span class="handle">@tmsu</span>
      </div>

      <div class="discord-status">
        <div class="status-indicator" id="statusIndicator"></div>
        <span class="status-label" id="statusLabel">...</span>
      </div>

      <span class="custom-status" id="customStatus"></span>

      <div class="now-playing" id="nowPlaying">
        <img class="spotify-art" id="spotifyArt" src="" alt="">
        <div class="bars">
          <div class="bar"></div>
          <div class="bar"></div>
          <div class="bar"></div>
          <div class="bar"></div>
        </div>
        <div class="track-info">
          <span class="track-label">Listening on Spotify</span>
          <span class="track-name" id="trackName">—</span>
          <span class="track-artist" id="trackArtist">—</span>
        </div>
      </div>

    </div>
  </div>
</div>

<script>
  const DISCORD_ID   = '1439946318083784866';
  const LANYARD_HTTP = `https://api.lanyard.rest/v1/users/${DISCORD_ID}`;
  const LANYARD_WS   = 'wss://api.lanyard.rest/socket';

  const enterScreen     = document.getElementById('enter-screen');
  const mainWrap        = document.getElementById('main-wrap');
  const card            = document.getElementById('card');
  const avatarBadge     = document.getElementById('avatarBadge');
  const statusIndicator = document.getElementById('statusIndicator');
  const statusLabel     = document.getElementById('statusLabel');
  const customStatus    = document.getElementById('customStatus');
  const nowPlaying      = document.getElementById('nowPlaying');
  const spotifyArt      = document.getElementById('spotifyArt');
  const trackName       = document.getElementById('trackName');
  const trackArtist     = document.getElementById('trackArtist');
  const audio           = document.getElementById('preview-audio');

  const STATUS_LABELS = {
    online: 'Online', idle: 'Idle',
    dnd: 'Do Not Disturb', offline: 'Offline'
  };

  // ── ENTER ──
  let entered     = false;
  let pendingPlay = false;

  enterScreen.addEventListener('click', () => {
    if (entered) return;
    entered = true;
    enterScreen.classList.add('hiding');
    mainWrap.classList.add('revealed');
    if (pendingPlay) { audio.play().catch(() => {}); pendingPlay = false; }
    setTimeout(() => enterScreen.remove(), 1000);
  });

  // ── AUDIO ──
  let currentTrackId = null;

  async function loadPreview(trackId) {
    if (!trackId || trackId === currentTrackId) return;
    currentTrackId = trackId;
    try {
      const proxy = `https://api.allorigins.win/raw?url=${encodeURIComponent('https://open.spotify.com/track/' + trackId)}`;
      const html  = await fetch(proxy).then(r => r.text());
      const match = html.match(/"preview_url"\s*:\s*"(https:[^"]+)"/);
      if (match) {
        audio.src    = match[1].replace(/\\/g, '');
        audio.loop   = true;
        audio.volume = 0.6;
        if (entered) audio.play().catch(() => {});
        else pendingPlay = true;
      }
    } catch(e) {}
  }

  function stopAudio() {
    audio.pause(); audio.src = '';
    currentTrackId = null; pendingPlay = false;
  }

  // ── PRESENCE ──
  function applyPresence(data) {
    const status = data.discord_status || 'offline';

    avatarBadge.className     = 'avatar-badge ' + status;
    statusIndicator.className = 'status-indicator ' + status;
    statusLabel.textContent   = STATUS_LABELS[status] || status;

    // Custom status
    const cs = (data.activities || []).find(a => a.type === 4);
    if (cs && (cs.state || cs.emoji?.name)) {
      customStatus.textContent   = (cs.emoji?.name ? cs.emoji.name + ' ' : '') + (cs.state || '');
      customStatus.style.display = 'block';
    } else {
      customStatus.style.display = 'none';
    }

    // Spotify
    const spotify = data.spotify;
    if (status !== 'offline' && spotify) {
      trackName.textContent   = spotify.song   || '—';
      trackArtist.textContent = spotify.artist || '—';
      if (spotify.album_art_url) {
        spotifyArt.src    = spotify.album_art_url;
        spotifyArt.onload  = () => spotifyArt.classList.add('loaded');
        spotifyArt.onerror = () => spotifyArt.classList.remove('loaded');
      }
      nowPlaying.classList.add('visible');
      if (spotify.track_id) loadPreview(spotify.track_id);
    } else {
      nowPlaying.classList.remove('visible');
      spotifyArt.classList.remove('loaded');
      stopAudio();
    }
  }

  // ── WEBSOCKET ──
  function connectWS() {
    const ws = new WebSocket(LANYARD_WS);
    let hb;
    ws.onmessage = ({ data }) => {
      const msg = JSON.parse(data);
      if (msg.op === 1) {
        ws.send(JSON.stringify({ op: 2, d: { subscribe_to_id: DISCORD_ID } }));
        hb = setInterval(() => ws.send(JSON.stringify({ op: 3 })), msg.d.heartbeat_interval);
      }
      if (msg.op === 0) applyPresence(msg.d);
    };
    ws.onclose = () => { clearInterval(hb); setTimeout(connectWS, 3000); };
    ws.onerror = () => ws.close();
  }

  fetch(LANYARD_HTTP).then(r => r.json()).then(j => { if (j.data) applyPresence(j.data); }).catch(() => {});
  connectWS();

  // ── EDGE TILT ──
  const EDGE  = 0.28;
  const MAX_T = 6;

  let targetX = 0, targetY = 0;
  let currentX = 0, currentY = 0;
  let hovering = false;
  let rafId = null;

  function calcTilt(px, py, rect) {
    const cx = (px - rect.left)  / rect.width;
    const cy = (py - rect.top)   / rect.height;
    let tx = 0, ty = 0;
    if (cx < EDGE)        tx = -(1 - cx / EDGE);
    else if (cx > 1-EDGE) tx =  (cx - (1 - EDGE)) / EDGE;
    if (cy < EDGE)        ty =  (1 - cy / EDGE);
    else if (cy > 1-EDGE) ty = -((cy - (1 - EDGE)) / EDGE);
    return { rotX: ty * MAX_T, rotY: tx * MAX_T };
  }

  function lerp(a, b, t) { return a + (b - a) * t; }

  function tiltLoop() {
    currentX = lerp(currentX, targetX, 0.1);
    currentY = lerp(currentY, targetY, 0.1);
    card.style.transform = `perspective(1400px) rotateX(${currentX.toFixed(3)}deg) rotateY(${currentY.toFixed(3)}deg)`;
    const stillMoving = Math.abs(currentX - targetX) > 0.01 || Math.abs(currentY - targetY) > 0.01;
    if (hovering || stillMoving) rafId = requestAnimationFrame(tiltLoop);
    else { rafId = null; card.style.transform = ''; }
  }

  function startLoop() {
    if (!rafId) rafId = requestAnimationFrame(tiltLoop);
  }

  card.addEventListener('mouseenter', () => { hovering = true; startLoop(); });

  card.addEventListener('mousemove', e => {
    e.stopPropagation();
    const { rotX, rotY } = calcTilt(e.clientX, e.clientY, card.getBoundingClientRect());
    targetX = rotX; targetY = rotY;
  });

  card.addEventListener('mouseleave', () => {
    hovering = false;
    targetX = 0; targetY = 0;
    startLoop();
  });

  card.addEventListener('touchmove', e => {
    const t = e.touches[0];
    const { rotX, rotY } = calcTilt(t.clientX, t.clientY, card.getBoundingClientRect());
    targetX = rotX; targetY = rotY;
    hovering = true; startLoop();
  }, { passive: true });

  card.addEventListener('touchend', () => {
    hovering = false; targetX = 0; targetY = 0; startLoop();
  });
</script>
</body>
</html>
